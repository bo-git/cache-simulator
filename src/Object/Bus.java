package Object;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;

/**
 * Created by Bo on 11/6/14.
 */
public class Bus {

    static final int BUS_READ = 1;
    static final int BUS_READEX = 2;
    static final int BUS_FLUSH = 3;
    static final String LOG_PATH = "logs/Bus";

    static int numOfProc, dataOnBus;
    static boolean isBlocked, isHighPriorityOps;
    public static boolean isBusTransactionComplete;
    static Vector<Processor> processors;
    static Queue<List<OperationPair>> busOperations;
    static List<OperationPair> cycleOps;
    static int expectedTerminationCycle;
    static OperationPair highPriorityOps;
    static String fileN;

    static BusLine busLine; //where cache snoops, check for results

    public static void initBus(Vector<Processor> procs, String fileName) {
        busOperations = new LinkedList<List<OperationPair>>();
        processors = procs;
        cycleOps = new ArrayList<OperationPair>();
        numOfProc = procs.size();
        expectedTerminationCycle = -1;
        fileN = fileName;
        busLine = new BusLine();
    }

    public static void accessMemory() { //set data early, ensure flow
        dataOnBus++;
        busLine.setResult(true);
    }

    public static int getDataOnBus() {
        return dataOnBus;
    }

    public static void insertTransactionOnBus(OperationPair op ) {
//        System.out.println("Generated by proc: "+op.getInitiatorNumber()+"  tx: "+op.getOpsNumber());
        cycleOps.add(op);
    }

    public static int isAllOpsFinished() {
        return busOperations.size();
    }

    public static boolean checkBusBlock() {
        if(busLine.getIsReceived())
            isBlocked = false;
        else
            isBlocked = true;
        return isBlocked;
    }

    public static void executeBusTransactions(int currCycle) {
        if(!cycleOps.isEmpty()) {
            busOperations.add(new ArrayList<OperationPair>(cycleOps));
            cycleOps.clear();
        }
        if(currCycle == expectedTerminationCycle)
            isBusTransactionComplete = true;
        else
            isBusTransactionComplete = false;

//        if(!busOperations.isEmpty()) {
//            System.out.print("\n@ cycle "+currCycle+" ,tobe executed in seq: ");
//            for(List<OperationPair> i : busOperations) {
//                System.out.print("[ ");
//                for(OperationPair op : i) {
//                    System.out.print(op.getOpsNumber()+" "+"from "+op.getInitiatorNumber()+" ");
//                }
//                System.out.println("]");
//            }
//        }
        if(!checkBusBlock()) {
            if (isHighPriorityOps) {
                busLine.setBusLine(highPriorityOps);
                busLine.setResult(true);
                isHighPriorityOps = false;
                setExpectedTerminationCycle(highPriorityOps.getOpsNumber(), currCycle);
//                System.out.println("decide to execute : " + highPriorityOps.getOpsNumber() + " from " + highPriorityOps.getInitiatorNumber());
            } else if (!busOperations.isEmpty()) {
                busLine = new BusLine();
                OperationPair op;
                List<OperationPair> busCycleOps = busOperations.peek();
                int index = random(busCycleOps.size() - 1);
                if (busCycleOps.size() > 1) {
                    op = busCycleOps.get(index);
                    busCycleOps.remove(index);
                } else
                    op = busOperations.poll().get(0);
//                System.out.println("decide to execute : " + op.getOpsNumber() + " from " + op.getInitiatorNumber());
                busLine.setBusLine(op);
                setExpectedTerminationCycle(op.getOpsNumber(), currCycle);
            }

        }
    }

    public static void continueBusReadorEx(int cycle) {
        expectedTerminationCycle = cycle + 6;
        accessMemory();
    }

    public static void resetExpectedTerminationCycle(int cycle, int time) {
        expectedTerminationCycle = cycle + time;
    }

    public static void setHighPriorityOps(OperationPair op) {
        isHighPriorityOps = true;
        highPriorityOps = op;
    }

    public static void setExpectedTerminationCycle(int opsNum, int cycle) {
        if((opsNum == BUS_READ || opsNum == BUS_READEX) && numOfProc > 1)
            expectedTerminationCycle = cycle + 2;
        else if (opsNum == BUS_FLUSH && numOfProc > 1) {
            accessMemory();
            expectedTerminationCycle = cycle + 8; //one cycle is used to supply data
        } else if (numOfProc == 1) {
            dataOnBus++;
            expectedTerminationCycle = cycle + 10;
        }
        isBusTransactionComplete = false;
    }

    static int random(int size) {
        Random r = new Random();
        return r.nextInt(size+1);
    }

    public static void log(long time) throws IOException {
        BufferedWriter bw = new BufferedWriter(new FileWriter(LOG_PATH+" "+fileN+".txt", false));
        bw.write("Number of data:\t\t\t"+dataOnBus);
        bw.newLine();
        bw.write("time taken:\t\t\t"+time);
        bw.newLine();
        bw.flush();
        bw.close();
    }

    public static void main(String[] args) {
        System.out.println(Bus.random(2-1));
    }

}

class OperationPair implements Comparable<OperationPair> {
    private int cycleNum;
    private int opsNumber;
    private int initiatorNumber;
    private String address;
    private int prevOpNumber;

    public OperationPair(int ops, int initNum, String address, int cycleNum) {
        this.opsNumber = ops;
        this.initiatorNumber = initNum;
        this.address = address;
        this.cycleNum = cycleNum;
        prevOpNumber = -1;
    }

    public OperationPair(int ops, int initNum, String address, int cycleNum, int prev) {
        this.opsNumber = ops;
        this.initiatorNumber = initNum;
        this.address = address;
        this.cycleNum = cycleNum;
        this.prevOpNumber = prev;
    }

    public int getOpsNumber() {
        return opsNumber;
    }

    public int getInitiatorNumber() {
        return initiatorNumber;
    }

    public String getAddress() {
        return address;
    }

    public int getPrevOps() {
        return prevOpNumber;
    }

    public void setPrevOpNumber(int opNum) {
        this.prevOpNumber = opNum;
    }

    @Override
    public int compareTo(OperationPair o) {
        if(opsNumber == o.opsNumber && initiatorNumber == o.initiatorNumber)
            return 1;
        return 0;
    }
}

class BusLine {
    private OperationPair currServingOperation;
    private boolean result;
    private boolean isReceived;

    public BusLine() {
        currServingOperation = null;
        this.result = false;
        this.isReceived = true;
    }

    public void setBusLine(OperationPair op) {
        currServingOperation = op;
        this.result = false;
        this.isReceived = false;
    }

    public int getReceiverProcessorNumberOnBus() {
        return currServingOperation.getInitiatorNumber();
    }

    public boolean getResultOnBus() {
        return result;
    }

    public String getCurrOpAddresOnBus() {
        return currServingOperation.getAddress();
    }

    public void setResult(boolean result) {
        this.result = result;
    }

    public OperationPair getOp() {
        return currServingOperation;
    }

    public void setReceived() {
        isReceived = true;
    }

    public boolean getIsReceived() {
        return this.isReceived;
    }
}
