package Object;

import java.util.*;

/**
 * Created by Bo on 11/6/14.
 */
public class Bus {

    static final int BUS_READ = 1;
    static final int BUS_READEX = 2;
    static final int BUS_FLUSH = 3;
    static final int BUS_ACCESS_MEMORY_WRITE = 4;
    static final int BUS_ACCESS_MEMORY_READ = 5;

    static int numOfProc;
    static int dataOnBus;
    static boolean isBlocked;
    static boolean isBusTransactionComplete;
    static Vector<Processor> processors;
    static Queue<List<OperationPair>> busOperations;
    static List<OperationPair> cycleOps;
    static int expectedTerminationCycle;

    static BusLine busLine; //where cache snoops, check for results

    public static void initBus(Vector<Processor> procs) {
        busOperations = new LinkedList<List<OperationPair>>();
        processors = procs;
        cycleOps = new ArrayList<OperationPair>();
        numOfProc = procs.size();
        expectedTerminationCycle = -1;
        busLine = new BusLine();
    }

    public static void accessMemory() { //set data early, ensure flow
        busLine.setResult(true);
    }

    public static int getDataOnBus() {
        return dataOnBus;
    }

    public static void insertTransactionOnBus(OperationPair op ) {
        System.out.println("Generated by proc: "+op.getInitiatorNumber()+"  tx: "+op.getOpsNumber());
        cycleOps.add(op);
    }

    public static boolean isBusBlocked() {
        return isBlocked;
    }

    public static boolean checkBusBlock() {
        if(busLine.getIsReceived())
            isBlocked = false;
        else
            isBlocked = true;
        return isBlocked;
    }

    public static void executeBusTransactions(int currCycle) {
        if(!cycleOps.isEmpty()) {
            busOperations.add(new ArrayList<OperationPair>(cycleOps));
            cycleOps.clear();
        }
        if(currCycle == expectedTerminationCycle)
            isBusTransactionComplete = true;
        else
            isBusTransactionComplete = false;

//        if(!busOperations.isEmpty()) {
//            System.out.print("@ cycle "+currCycle+" ,tobe executed in seq: ");
//            for(List<OperationPair> i : busOperations) {
//                System.out.print("[ ");
//                for(OperationPair op : i) {
//                    System.out.print(op.getOpsNumber()+" "+"from "+op.getInitiatorNumber()+" ");
//                }
//                System.out.println("]");
//            }
//        }
        if(!busOperations.isEmpty() && !checkBusBlock()) {
            busLine = new BusLine();
            OperationPair op;
            List<OperationPair> busCycleOps = busOperations.peek();
            int index = random(busCycleOps.size()-1);
            if(busCycleOps.size() > 1) {
                op = busCycleOps.get(index);
                busCycleOps.remove(index);
            } else
                op = busOperations.poll().get(0);
//            System.out.println("decide to execute : "+op.getOpsNumber()+" from "+op.getInitiatorNumber());
            setExpectedTerminationCycle(op.getOpsNumber(), currCycle);
            busLine.setBusLine(op);


            if(op.getOpsNumber() == BUS_ACCESS_MEMORY_READ ||
                    op.getOpsNumber() == BUS_ACCESS_MEMORY_WRITE ||
                    op.getOpsNumber() == BUS_FLUSH)
                accessMemory();

        }else {
//            System.out.println("bus block: "+isBusBlocked()+"  ops count: "+busOperations.size());
        }
    }

    public static void setExpectedTerminationCycle(int opsNum, int cycle) {
        if(opsNum == BUS_ACCESS_MEMORY_READ ||
                opsNum == BUS_ACCESS_MEMORY_WRITE ||
                opsNum == BUS_FLUSH)
            expectedTerminationCycle = cycle + 10;
        else if(opsNum == BUS_READ || opsNum == BUS_READEX)
            expectedTerminationCycle = cycle + 2;
        isBusTransactionComplete = false;
    }

    static int random(int size) {
        Random r = new Random();
        return r.nextInt(size+1);
    }

    public static void main(String[] args) {
        System.out.println(Bus.random(2-1));
    }

}

class OperationPair implements Comparable<OperationPair> {
    private int cycleNum;
    private int opsNumber;
    private int initiatorNumber;
    private String address;
    private int prevOpNumber;

    public OperationPair(int ops, int initNum, String address, int cycleNum) {
        this.opsNumber = ops;
        this.initiatorNumber = initNum;
        this.address = address;
        this.cycleNum = cycleNum;
        prevOpNumber = -1;
    }

    public OperationPair(int ops, int initNum, String address, int cycleNum, int prev) {
        this.opsNumber = ops;
        this.initiatorNumber = initNum;
        this.address = address;
        this.cycleNum = cycleNum;
        this.prevOpNumber = prev;
    }

    public int getOpsNumber() {
        return opsNumber;
    }

    public int getInitiatorNumber() {
        return initiatorNumber;
    }

    public String getAddress() {
        return address;
    }

    public int getPrevOps() {
        return prevOpNumber;
    }

    @Override
    public int compareTo(OperationPair o) {
        if(opsNumber == o.opsNumber && initiatorNumber == o.initiatorNumber)
            return 1;
        return 0;
    }
}

class BusLine {
    private OperationPair currServingOperation;
    private boolean result;
    private boolean isReceived;

    public BusLine() {
        currServingOperation = null;
        this.result = false;
        this.isReceived = true;
    }

    public void setBusLine(OperationPair op) {
        currServingOperation = op;
        this.result = false;
        this.isReceived = false;
    }

    public int getReceiverProcessorNumberOnBus() {
        return currServingOperation.getInitiatorNumber();
    }

    public boolean getResultOnBus() {
        return result;
    }

    public String getCurrOpAddresOnBus() {
        return currServingOperation.getAddress();
    }

    public void setResult(boolean result) {
        this.result = result;
    }

    public OperationPair getOp() {
        return currServingOperation;
    }

    public void setReceived() {
        isReceived = true;
    }

    public boolean getIsReceived() {
        return this.isReceived;
    }
}
